// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.21.11
// source: pb/evaluation.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	EvaInfo_CreateEvaluation_FullMethodName = "/pb.Eva_info/CreateEvaluation"
	EvaInfo_DeleteEvaluation_FullMethodName = "/pb.Eva_info/DeleteEvaluation"
	EvaInfo_GetEvaluation_FullMethodName    = "/pb.Eva_info/GetEvaluation"
	EvaInfo_UpdateEvaluation_FullMethodName = "/pb.Eva_info/UpdateEvaluation"
)

// EvaInfoClient is the client API for EvaInfo service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EvaInfoClient interface {
	CreateEvaluation(ctx context.Context, in *CreateEvaluationRequest, opts ...grpc.CallOption) (*StatusResponse, error)
	DeleteEvaluation(ctx context.Context, in *DeleteEvaluationRequest, opts ...grpc.CallOption) (*StatusResponse, error)
	GetEvaluation(ctx context.Context, in *GetEvaluationRequest, opts ...grpc.CallOption) (*EvaluationResponse, error)
	UpdateEvaluation(ctx context.Context, in *UpdateEvaluationRequest, opts ...grpc.CallOption) (*StatusResponse, error)
}

type evaInfoClient struct {
	cc grpc.ClientConnInterface
}

func NewEvaInfoClient(cc grpc.ClientConnInterface) EvaInfoClient {
	return &evaInfoClient{cc}
}

func (c *evaInfoClient) CreateEvaluation(ctx context.Context, in *CreateEvaluationRequest, opts ...grpc.CallOption) (*StatusResponse, error) {
	out := new(StatusResponse)
	err := c.cc.Invoke(ctx, EvaInfo_CreateEvaluation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evaInfoClient) DeleteEvaluation(ctx context.Context, in *DeleteEvaluationRequest, opts ...grpc.CallOption) (*StatusResponse, error) {
	out := new(StatusResponse)
	err := c.cc.Invoke(ctx, EvaInfo_DeleteEvaluation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evaInfoClient) GetEvaluation(ctx context.Context, in *GetEvaluationRequest, opts ...grpc.CallOption) (*EvaluationResponse, error) {
	out := new(EvaluationResponse)
	err := c.cc.Invoke(ctx, EvaInfo_GetEvaluation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evaInfoClient) UpdateEvaluation(ctx context.Context, in *UpdateEvaluationRequest, opts ...grpc.CallOption) (*StatusResponse, error) {
	out := new(StatusResponse)
	err := c.cc.Invoke(ctx, EvaInfo_UpdateEvaluation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EvaInfoServer is the server API for EvaInfo service.
// All implementations must embed UnimplementedEvaInfoServer
// for forward compatibility
type EvaInfoServer interface {
	CreateEvaluation(context.Context, *CreateEvaluationRequest) (*StatusResponse, error)
	DeleteEvaluation(context.Context, *DeleteEvaluationRequest) (*StatusResponse, error)
	GetEvaluation(context.Context, *GetEvaluationRequest) (*EvaluationResponse, error)
	UpdateEvaluation(context.Context, *UpdateEvaluationRequest) (*StatusResponse, error)
	mustEmbedUnimplementedEvaInfoServer()
}

// UnimplementedEvaInfoServer must be embedded to have forward compatible implementations.
type UnimplementedEvaInfoServer struct {
}

func (UnimplementedEvaInfoServer) CreateEvaluation(context.Context, *CreateEvaluationRequest) (*StatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateEvaluation not implemented")
}
func (UnimplementedEvaInfoServer) DeleteEvaluation(context.Context, *DeleteEvaluationRequest) (*StatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteEvaluation not implemented")
}
func (UnimplementedEvaInfoServer) GetEvaluation(context.Context, *GetEvaluationRequest) (*EvaluationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEvaluation not implemented")
}
func (UnimplementedEvaInfoServer) UpdateEvaluation(context.Context, *UpdateEvaluationRequest) (*StatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateEvaluation not implemented")
}
func (UnimplementedEvaInfoServer) mustEmbedUnimplementedEvaInfoServer() {}

// UnsafeEvaInfoServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EvaInfoServer will
// result in compilation errors.
type UnsafeEvaInfoServer interface {
	mustEmbedUnimplementedEvaInfoServer()
}

func RegisterEvaInfoServer(s grpc.ServiceRegistrar, srv EvaInfoServer) {
	s.RegisterService(&EvaInfo_ServiceDesc, srv)
}

func _EvaInfo_CreateEvaluation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateEvaluationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvaInfoServer).CreateEvaluation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EvaInfo_CreateEvaluation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvaInfoServer).CreateEvaluation(ctx, req.(*CreateEvaluationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvaInfo_DeleteEvaluation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteEvaluationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvaInfoServer).DeleteEvaluation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EvaInfo_DeleteEvaluation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvaInfoServer).DeleteEvaluation(ctx, req.(*DeleteEvaluationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvaInfo_GetEvaluation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEvaluationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvaInfoServer).GetEvaluation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EvaInfo_GetEvaluation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvaInfoServer).GetEvaluation(ctx, req.(*GetEvaluationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvaInfo_UpdateEvaluation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateEvaluationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvaInfoServer).UpdateEvaluation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EvaInfo_UpdateEvaluation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvaInfoServer).UpdateEvaluation(ctx, req.(*UpdateEvaluationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EvaInfo_ServiceDesc is the grpc.ServiceDesc for EvaInfo service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EvaInfo_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Eva_info",
	HandlerType: (*EvaInfoServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateEvaluation",
			Handler:    _EvaInfo_CreateEvaluation_Handler,
		},
		{
			MethodName: "DeleteEvaluation",
			Handler:    _EvaInfo_DeleteEvaluation_Handler,
		},
		{
			MethodName: "GetEvaluation",
			Handler:    _EvaInfo_GetEvaluation_Handler,
		},
		{
			MethodName: "UpdateEvaluation",
			Handler:    _EvaInfo_UpdateEvaluation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pb/evaluation.proto",
}

const (
	EvaLike_SetLike_FullMethodName = "/pb.Eva_like/SetLike"
	EvaLike_GetLike_FullMethodName = "/pb.Eva_like/GetLike"
)

// EvaLikeClient is the client API for EvaLike service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EvaLikeClient interface {
	SetLike(ctx context.Context, in *SetLikeRequest, opts ...grpc.CallOption) (*StatusResponse, error)
	GetLike(ctx context.Context, in *GetLikeRequest, opts ...grpc.CallOption) (*GetLikeResponse, error)
}

type evaLikeClient struct {
	cc grpc.ClientConnInterface
}

func NewEvaLikeClient(cc grpc.ClientConnInterface) EvaLikeClient {
	return &evaLikeClient{cc}
}

func (c *evaLikeClient) SetLike(ctx context.Context, in *SetLikeRequest, opts ...grpc.CallOption) (*StatusResponse, error) {
	out := new(StatusResponse)
	err := c.cc.Invoke(ctx, EvaLike_SetLike_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evaLikeClient) GetLike(ctx context.Context, in *GetLikeRequest, opts ...grpc.CallOption) (*GetLikeResponse, error) {
	out := new(GetLikeResponse)
	err := c.cc.Invoke(ctx, EvaLike_GetLike_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EvaLikeServer is the server API for EvaLike service.
// All implementations must embed UnimplementedEvaLikeServer
// for forward compatibility
type EvaLikeServer interface {
	SetLike(context.Context, *SetLikeRequest) (*StatusResponse, error)
	GetLike(context.Context, *GetLikeRequest) (*GetLikeResponse, error)
	mustEmbedUnimplementedEvaLikeServer()
}

// UnimplementedEvaLikeServer must be embedded to have forward compatible implementations.
type UnimplementedEvaLikeServer struct {
}

func (UnimplementedEvaLikeServer) SetLike(context.Context, *SetLikeRequest) (*StatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLike not implemented")
}
func (UnimplementedEvaLikeServer) GetLike(context.Context, *GetLikeRequest) (*GetLikeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLike not implemented")
}
func (UnimplementedEvaLikeServer) mustEmbedUnimplementedEvaLikeServer() {}

// UnsafeEvaLikeServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EvaLikeServer will
// result in compilation errors.
type UnsafeEvaLikeServer interface {
	mustEmbedUnimplementedEvaLikeServer()
}

func RegisterEvaLikeServer(s grpc.ServiceRegistrar, srv EvaLikeServer) {
	s.RegisterService(&EvaLike_ServiceDesc, srv)
}

func _EvaLike_SetLike_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetLikeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvaLikeServer).SetLike(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EvaLike_SetLike_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvaLikeServer).SetLike(ctx, req.(*SetLikeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvaLike_GetLike_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLikeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvaLikeServer).GetLike(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EvaLike_GetLike_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvaLikeServer).GetLike(ctx, req.(*GetLikeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EvaLike_ServiceDesc is the grpc.ServiceDesc for EvaLike service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EvaLike_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Eva_like",
	HandlerType: (*EvaLikeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetLike",
			Handler:    _EvaLike_SetLike_Handler,
		},
		{
			MethodName: "GetLike",
			Handler:    _EvaLike_GetLike_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pb/evaluation.proto",
}

const (
	EvaReport_SendReport_FullMethodName   = "/pb.Eva_report/SendReport"
	EvaReport_GetReports_FullMethodName   = "/pb.Eva_report/GetReports"
	EvaReport_GetTheReport_FullMethodName = "/pb.Eva_report/GetTheReport"
	EvaReport_SetReport_FullMethodName    = "/pb.Eva_report/SetReport"
)

// EvaReportClient is the client API for EvaReport service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EvaReportClient interface {
	SendReport(ctx context.Context, in *SendReportRequest, opts ...grpc.CallOption) (*StatusResponse, error)
	GetReports(ctx context.Context, in *GetReportsRequest, opts ...grpc.CallOption) (*GetReportsResponse, error)
	GetTheReport(ctx context.Context, in *GetTheReportRequest, opts ...grpc.CallOption) (*GetTheReportResponse, error)
	SetReport(ctx context.Context, in *SetReportRequest, opts ...grpc.CallOption) (*StatusResponse, error)
}

type evaReportClient struct {
	cc grpc.ClientConnInterface
}

func NewEvaReportClient(cc grpc.ClientConnInterface) EvaReportClient {
	return &evaReportClient{cc}
}

func (c *evaReportClient) SendReport(ctx context.Context, in *SendReportRequest, opts ...grpc.CallOption) (*StatusResponse, error) {
	out := new(StatusResponse)
	err := c.cc.Invoke(ctx, EvaReport_SendReport_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evaReportClient) GetReports(ctx context.Context, in *GetReportsRequest, opts ...grpc.CallOption) (*GetReportsResponse, error) {
	out := new(GetReportsResponse)
	err := c.cc.Invoke(ctx, EvaReport_GetReports_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evaReportClient) GetTheReport(ctx context.Context, in *GetTheReportRequest, opts ...grpc.CallOption) (*GetTheReportResponse, error) {
	out := new(GetTheReportResponse)
	err := c.cc.Invoke(ctx, EvaReport_GetTheReport_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evaReportClient) SetReport(ctx context.Context, in *SetReportRequest, opts ...grpc.CallOption) (*StatusResponse, error) {
	out := new(StatusResponse)
	err := c.cc.Invoke(ctx, EvaReport_SetReport_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EvaReportServer is the server API for EvaReport service.
// All implementations must embed UnimplementedEvaReportServer
// for forward compatibility
type EvaReportServer interface {
	SendReport(context.Context, *SendReportRequest) (*StatusResponse, error)
	GetReports(context.Context, *GetReportsRequest) (*GetReportsResponse, error)
	GetTheReport(context.Context, *GetTheReportRequest) (*GetTheReportResponse, error)
	SetReport(context.Context, *SetReportRequest) (*StatusResponse, error)
	mustEmbedUnimplementedEvaReportServer()
}

// UnimplementedEvaReportServer must be embedded to have forward compatible implementations.
type UnimplementedEvaReportServer struct {
}

func (UnimplementedEvaReportServer) SendReport(context.Context, *SendReportRequest) (*StatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendReport not implemented")
}
func (UnimplementedEvaReportServer) GetReports(context.Context, *GetReportsRequest) (*GetReportsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetReports not implemented")
}
func (UnimplementedEvaReportServer) GetTheReport(context.Context, *GetTheReportRequest) (*GetTheReportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTheReport not implemented")
}
func (UnimplementedEvaReportServer) SetReport(context.Context, *SetReportRequest) (*StatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetReport not implemented")
}
func (UnimplementedEvaReportServer) mustEmbedUnimplementedEvaReportServer() {}

// UnsafeEvaReportServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EvaReportServer will
// result in compilation errors.
type UnsafeEvaReportServer interface {
	mustEmbedUnimplementedEvaReportServer()
}

func RegisterEvaReportServer(s grpc.ServiceRegistrar, srv EvaReportServer) {
	s.RegisterService(&EvaReport_ServiceDesc, srv)
}

func _EvaReport_SendReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvaReportServer).SendReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EvaReport_SendReport_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvaReportServer).SendReport(ctx, req.(*SendReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvaReport_GetReports_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetReportsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvaReportServer).GetReports(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EvaReport_GetReports_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvaReportServer).GetReports(ctx, req.(*GetReportsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvaReport_GetTheReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTheReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvaReportServer).GetTheReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EvaReport_GetTheReport_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvaReportServer).GetTheReport(ctx, req.(*GetTheReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvaReport_SetReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvaReportServer).SetReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EvaReport_SetReport_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvaReportServer).SetReport(ctx, req.(*SetReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EvaReport_ServiceDesc is the grpc.ServiceDesc for EvaReport service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EvaReport_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Eva_report",
	HandlerType: (*EvaReportServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendReport",
			Handler:    _EvaReport_SendReport_Handler,
		},
		{
			MethodName: "GetReports",
			Handler:    _EvaReport_GetReports_Handler,
		},
		{
			MethodName: "GetTheReport",
			Handler:    _EvaReport_GetTheReport_Handler,
		},
		{
			MethodName: "SetReport",
			Handler:    _EvaReport_SetReport_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pb/evaluation.proto",
}
